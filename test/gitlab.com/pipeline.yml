stages:
  - bootstrap    # set up container images for CI
  - ch           # actual CI
  - downstream   # run dependent pipelines in other projects

variables:
  # https://docs.gitlab.com/runner/configuration/feature-flags.html
  FF_DISABLE_UMASK_FOR_DOCKER_EXECUTOR: true      # fix permissions
  FF_SCRIPT_SECTIONS: true                        # tidier logs?
  FF_TIMESTAMPS: true                             # timestamps on log lines
  FF_USE_FASTZIP: true                            # faster archive creation
  CH_PIPELINE_MODE:
    description: "Pipeline mode to use."
    value: ci
    options:
      - ci
      - daily

workflow:
  name: "$CI_PIPELINE_SOURCE/$CI_COMMIT_BRANCH$CI_MERGE_REQUEST_IID/$CH_PIPELINE_MODE $CI_COMMIT_SHORT_SHA $CI_COMMIT_TITLE"
  rules:
    # Exclude branch pipelines for MRs.
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS
      when: never
    - when: always

# We cannot use “rules” in “default”. Therefore, every job should use exactly
# one of these anchors.
.when-ci: &when-ci
  rules:
    - if: $CH_PIPELINE_MODE == "ci"
      when: always
.when-ci-main: &when-ci-main
  # This anchor is to trigger downstream pipelines that use the main branch.
  # It runs for any of (a) manually triggered pipelines, (b) pushes to main,
  # and (c) MR pushes if the MR is labelled “ci-downstream”. Triggering the
  # downstream pipelines when they shouldn’t be should have no effect other
  # than wasting resources.
  rules:
    - if:    $CI_PIPELINE_SOURCE == "web"
          || (    $CH_PIPELINE_MODE == "ci"
               && (    $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
                    || $CI_MERGE_REQUEST_LABELS =~ /ci-downstream/ ) )
      when: always
.when-daily: &when-daily
  rules:
    - if: $CH_PIPELINE_MODE == "daily"
      when: always
.when-always: &when-always
  rules:
    - when: always

default:
  # Use an image tagged with the branch name because “:latest” is not
  # well-defined if multiple branches are open (see issue #1981).
  image: $CI_REGISTRY_IMAGE/ci_debian:$CI_COMMIT_REF_NAME
  artifacts:
    expire_in: 1 week
    name: ${CI_JOB_NAME}_${CI_COMMIT_SHORT_SHA}
  before_script:
    - export LC_ALL=C  # boring and consistent
    - ./test/gitlab.com/info.sh

ci-images:
  # Build the images used for the rest of the pipeline, if needed [1]. Notes:
  #
  # 1. This uses a second “service” container for the Docker daemon, which
  #    seems unnecessary to me, but I couldn’t figure out how to start the
  #    Docker daemon in a tidy way otherwise. It’s also how the examples in
  #    the docs do it.
  #
  # 2. We enable TLS, which also seems unnecessary but the docs encourage it
  #    and the Docker daemon yells if you don’t.
  #
  # [1]: https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
  stage: bootstrap
  image: docker:27-cli       # client tools only?
  <<: *when-always
  tags: ["saas-linux-medium-${ci_arch}"]
  parallel:
    matrix:
      - ci_arch: [amd64]
        ci_distro: [debian]
  variables:
    # DOCKER_HOST set automatically
    DOCKER_TLS_CERTDIR: "/certs"
  services:
    - name: docker:27-dind
      alias: daemon
  script:
    -   echo "$CI_REGISTRY_PASSWORD"
      | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - ./test/gitlab.com/build-images $ci_distro $CI_COMMIT_REF_NAME

review-nag:
  stage: ch
  <<: *when-daily
  tags: [saas-linux-small-amd64]
  script: |
    test/gitlab.com/reviews-email --to   $CH_DLQ_TO \
                                  --from $CH_DLQ_FROM \
                                  --host $CH_DLQ_HOST \
                                  --port $CH_DLQ_PORT \
                                  --user $CH_DLQ_USER \
                                  --pass $CH_DLQ_PASS

loc:
  stage: ch
  <<: *when-ci
  tags: [saas-linux-small-amd64]
  script:
    - misc/loc

test:
  stage: ch
  <<: *when-ci
  tags: ["saas-linux-medium-${ci_arch}"]
  parallel:
    matrix:
      # Core tests with everything turned on.
      - CH_TEST_BUILDER: [image]
        CH_IMAGE_CACHE: [enabled]
        CH_TEST_PACK_FMT: [squash-mount, squash-unpack, tar-unpack]
        ci_arch: [amd64]
        ci_distro: [debian]
        ci_sudo: [sudo_yes]
  artifacts:
    when: always
    untracked: true
  script:
    # Set up a tmpfs to hold the storage directory (to make it all faster).
    - sudo mount -t tmpfs tmpfs /mnt
    # Run the tests
    - test/gitlab.com/testjob.bash
    # Move target directory into Git WD so it’s included in the artifact.
    - sudo mv /ch .

website:
  # Re-deploy the website by triggering a pipeline in the website project,
  # i.e. https://gitlab.com/charliecloud/website.
  stage: downstream
  <<: *when-ci-main
  trigger:
    project: charliecloud/website
