#!/bin/bash

### Setup we need right away

set -e

# Set the locale so we have predictable sorting. However, image crashes on
# Python 3.6 in locale â€œCâ€ (see issues #970 and #1262), which is the only
# locale guaranteed to be available, so use a UTF-8 locale if available. This
# means tests will fail on Python 3.6 systems without this UTF-8 locale.
if [[ $(locale -a) = *en_US.utf8* ]]; then
    export LC_ALL=en_US.utf8
else
    export LC_ALL=C
fi

# Set environment variable for image --debug flag
export CLEARLY_IMAGE_DEBUG=true

# Set environment variable for convert and image --xattrs flag
export CLEARLY_XATTRS=true

### Functions we need right away

fatal () {
    printf 'error: %s\n' "$1" 1>&2
    exit 1
}

warning () {
    printf 'warning: %s\n' "$1" 1>&2
}


### Setup

clearly_lib=$(cd "$(dirname "$0")" && pwd)/../../lib
if [[ ! -f ${clearly_lib}/_base.sh ]]; then
    fatal "install or build problem: not found: ${clearly_lib}/_base.sh"
fi
. "${clearly_lib}/_base.sh"
export clearly_bin
export clearly_lib

if docker info > /dev/null 2>&1; then
    clearly_docker_nosudo=yes
else
    clearly_docker_nosudo=
fi
export clearly_docker_nosudo

usage=$(cat <<EOF
Run some or all of the test suite.

Usage:

  $ $(basename "$0") [PHASE] [--scope SCOPE] [--pack-fmt FMT] [OPTIONS]

Valid phases: build-images, build, rootemu, run, examples, all, most, mk-perm-dirs, clean,
              rm-perm-dirs
Valid scopes: quick, standard, full
Valid pack formats: squash-mount, tar-unpack, squash-unpack

Additional options:

  -b,--builder BUILDER   image builder to use
  --dry-run              print summary of what would be tested and exit
  -f,--file FILE[:TEST]  run tests in FILE only, or even just TEST
  -h,--help              print this help and exit
  --img-dir DIR          unpacked images directory; same as \$CLEARLY_TEST_IMGDIR
  --fi-path PATH         path to libfabric provider injection target(s)
  --pack-dir DIR         packed image directory; same as \$CLEARLY_TEST_TARDIR
  --pack-fmt FMT         packed image format; same as \$CLEARLY_TEST_PACK_FMT
  --pedandic {yes,no}    set pedantic mode rather than guessing
  --perm-dir DIR         permissions fixture dir, can repeat; \$CLEARLY_TEST_PERMDIRS
  --srun-mpi MPI         srun --mpi argument; see srun --mpi=list
  --sudo                 enable tests that need sudo
  --lustre DIR           run-phase Lustre test directory; \$CLEARLY_TEST_LUSTREDIR

See the man page for important details.
EOF
)


### Global variables

bats_vmin=1.2.0  # FIXME: get from configure somehow?


### Functions

builder_check () {
    printf 'checking builder ...\n'
    case $CLEARLY_TEST_BUILDER in
    image)
        if ! "${clearly_bin}/clearly image" --dependencies; then
            fatal 'builder: image: missing dependencies'
        fi
        bl=$(readlink -f "${clearly_bin}/clearly")
        bv=$("$bl" --version)
        ;;
    buildah)
        ;&
    buildah-runc)
        ;&
    buildah-setuid)
        if ! command -v buildah > /dev/null 2>&1; then
            fatal 'builder: buildah: not installed.'
        fi
        bl=$(command -v buildah)
        bv=$(buildah --version | awk '{print $3}')
        min='1.11.2'
        ;;
    docker)
        if ! command -v docker > /dev/null 2>&1; then
            fatal 'builder: docker: not installed'
        fi
        bl=$(command -v docker)
        bv=$(docker_ --version | awk '{print $3}' | sed -e 's/,$//')
        ;;
    none)
        bl='none'
        bv=
        ;;
    *)
        fatal "builder: $CLEARLY_TEST_BUILDER: not supported"
        ;;
    esac
    printf 'found: %s %s\n\n' "$bl" "$bv"
    version_check 'builder' "$min" "$bv"
}

builder_set () {
    width=$1
    if [[ -n $builder ]]; then
        CLEARLY_TEST_BUILDER=$builder
        method='command line'
    elif [[ -n $CLEARLY_TEST_BUILDER ]]; then
        method='environment'
    else
        CLEARLY_TEST_BUILDER=image
        method='default'
    fi
    printf "%-*s %s (%s)\n" "$width" 'builder:' "$CLEARLY_TEST_BUILDER" "$method"
    if [[ $CLEARLY_TEST_BUILDER == image ]]; then
        vset CLEARLY_IMAGE_STORAGE '' "$CLEARLY_IMAGE_STORAGE" "/var/tmp/clearly/images" \
                              "$width" 'image storage'
    fi
    export CLEARLY_TEST_BUILDER
}

# Create CLEARLY_TEST_IMGDIR, avoiding #347.
dir_img_mk () {
    dir_img_rm
    printf "creating %s\n\n" "$CLEARLY_TEST_IMGDIR"
    $clearly_mpirun_node mkdir "$CLEARLY_TEST_IMGDIR"
    $clearly_mpirun_node touch "$CLEARLY_TEST_IMGDIR/WEIRD_AL_YANKOVIC"
}

dir_img_rm () {
    dir_rm_safe "$CLEARLY_TEST_IMGDIR"
}

# Remove a filesystem permissions fixture directory. Ensure that the target
# directory has exactly the two subdirectories expected first.
dir_perm_rm () {
    if [[    $(find "${1}" -maxdepth 1 -mindepth 1 | wc -l) == 2 \
          && -d "${1}/pass" && -d "${1}/nopass" ]]; then
        echo "removing ${1}"
        sudo rm -rf --one-file-system "$1"
    fi
}

# Remove directory $1 if itâ€™s either 1) empty or 2) contains a sentinel file.
dir_rm_safe () {
    if [[    $(find "$1" -maxdepth 1 -mindepth 1 | wc -l) == 0 \
          || -e ${1}/WEIRD_AL_YANKOVIC ]]; then
        echo "removing $1"
        $clearly_mpirun_node rm -rf --one-file-system "$1"
    else
        fatal "non-empty and missing sentinel file; manually delete: $1"
    fi
}

# The run phase requires artifacts from a successful build phase. Thus, we
# check sanity based on the minimal set of artifacts (no builder).
dir_tar_check () {
    printf 'checking %s: ' "$CLEARLY_TEST_TARDIR"
    dir_tar_check_file test{.tar.gz,.sqfs}
    printf 'ok\n\n'
}

dir_tar_check_file () {
    local missing
    for f in "$@"; do
        if [[ -f ${CLEARLY_TEST_TARDIR}/${f} ]]; then
            return 0
        else
            missing+=("${CLEARLY_TEST_TARDIR}/${f}")
        fi
    done
    fatal "phase $phase: missing packed images: ${missing[*]}"
}

dir_tar_mk () {
    dir_tar_rm
    printf "creating %s\n\n" "$CLEARLY_TEST_TARDIR"
    $clearly_mpirun_node mkdir "$CLEARLY_TEST_TARDIR"
    $clearly_mpirun_node touch "${CLEARLY_TEST_TARDIR}/WEIRD_AL_YANKOVIC"
}

dir_tar_rm () {
    dir_rm_safe "$CLEARLY_TEST_TARDIR"
}

dir_tmp_rm () {
    if [[ $TMP_ == "/tmp/clearly-test.tmp.${USER}" ]]; then
        echo "removing $TMP_"
        rm -rf --one-file-system "$TMP_"
    fi
}

dirs_unpriv_rm () {
    dir_tar_rm
    dir_img_rm
    dir_tmp_rm
}

pack_fmt_set () {
    width=$1
    if command -v mksquashfs > /dev/null 2>&1; then
        have_mksquashfs=yes
    else
        have_mksquashfs=
    fi
    if [[ $(ldd "${clearly_bin}/run") = *"libsquashfuse"* ]]; then
        have_libsquashfuse=yes
    else
        have_libsquashfuse=
    fi
    if [[ -n $pack_fmt ]]; then
        CLEARLY_TEST_PACK_FMT=$pack_fmt
        method='command line'
    elif [[ -n $CLEARLY_TEST_PACK_FMT ]]; then
        method='environment'
    elif [[ -n $have_mksquashfs && -n $have_libsquashfuse ]]; then
        CLEARLY_TEST_PACK_FMT=squash-mount
        method='default'
    else
        CLEARLY_TEST_PACK_FMT=tar-unpack
        method='default'
    fi
    case $CLEARLY_TEST_PACK_FMT in
        'ðŸ˜')  # elephant emoji U+1F418
            CLEARLY_TEST_PACK_FMT=squash-mount
            ;;
        'ðŸ“ ')  # fax machine emoji U+1F4E0
            CLEARLY_TEST_PACK_FMT=tar-unpack
            ;;
        'ðŸŽƒ')  # jack-o-lantern emoji U+1F383
            CLEARLY_TEST_PACK_FMT=squash-unpack
            ;;
        esac
    export CLEARLY_TEST_PACK_FMT
    printf "%-*s %s (%s)\n" \
           "$width" 'packed image format:' "$CLEARLY_TEST_PACK_FMT" "$method"
    case $CLEARLY_TEST_PACK_FMT in
        squash-mount)
            if [[ -z $have_mksquashfs ]]; then
                fatal "format invalid: ${CLEARLY_TEST_PACK_FMT}: no mksquashfs"
            fi
            if [[ -z $have_libsquashfuse ]]; then
                fatal "format invalid: ${CLEARLY_TEST_PACK_FMT}: run not linked with libsquashfuse"
            fi
            ;;
        tar-unpack)
            ;;  # nothing to check (assume we have tar)
        squash-unpack)
            if [[ -z $have_mksquashfs ]]; then
                fatal "format invalid: ${CLEARLY_TEST_PACK_FMT}: no mksquashfs"
            fi
            ;;
        *)
            fatal "format unknown: ${CLEARLY_TEST_PACK_FMT}"
            ;;
    esac
}

pedantry_set () {
    width=$1
    default=no
    # Default to pedantic on CI.
    if [[ -n $CI ]]; then
        default=yes
    fi
    vset clearly_pedantic "$pedantic" '' $default "$width" 'pedantic mode'
    if [[ $clearly_pedantic == no ]]; then
        clearly_pedantic=  # proper boolean
    fi
    # Motivation here: In pedantic mode, we want to run all the tests we
    # reasonably can. So, if the user *has* sudo, then default --sudo to yes.
    # What is a little awkward is that â€œsudo trueâ€ can generate a password
    # prompt in the middle of the status output. An alternative is â€œsudo -nvâ€,
    # which doesnâ€™t; drawbacks are that you have to analyze the output (not
    # exit code) and it generates a failed password log message if there is
    # not already a sudo session going. We also used to use â€œsudo -vâ€, which
    # prompts for a password even if you have passwordless sudo set up.
    if    [[ -n $clearly_pedantic ]] \
       && command -v sudo > /dev/null \
       && sudo true > /dev/null 2>&1; then
        use_sudo_default=yes
    else
        use_sudo_default=
    fi
}

pq_missing () {
    if [[ $phase == all || $phase == build ]]; then
        local img=$1
        local out=$2
        local tag
        tag=$(test_make_auto tag "$img")
        printf '%s\n' "$out" >> "${CLEARLY_TEST_TARDIR}/${tag}.pq_missing"
    fi
}

require_unset () {
    name=$1
    value=${!1}
    if [[ -n $value ]]; then
        fatal "$name: no multiple assignment (already \"$value\")"
    fi
}

scope_check () {
    case $1 in
    quick|standard|full)
        return 0
        ;;
    *)
        fatal "invalid scope: $1"
        ;;
    esac
}

# Assign scope a sortable opaque integer value. This value is used to help
# filter images and tests that are out of scope.
scope_to_digit () {
    case $1 in
        quick)
            echo 1
            ;;
        standard)
            echo 2
            ;;
        full)
            echo 3
            ;;
        skip*)
            # skip has the highest value to ensure it is always filtered out
            echo 4
            ;;
        *)
            fatal "scope '$scope' invalid"
            ;;
    esac
}

test_build () {
    echo 'executing build phase tests ...'
    bats build/*.bats
}

test_build_images () {
    echo 'building images ...'
    if [[ ! -f ${TMP_}/build_auto.bats ]]; then
        fatal "${TMP_}/build_auto.bats not found"
    fi
    bats "${TMP_}/build_auto.bats"
}

test_examples () {
    printf '\n'
    if [[ $CLEARLY_TEST_SCOPE == quick ]]; then
        echo "no examples for $CLEARLY_TEST_SCOPE scope"
    fi
    echo 'executing example phase tests ...'
    if find "$TMP_" -name '*_example.bats' | grep -q .; then
        bats "${TMP_}"/*_example.bats
    fi
}

test_make () {
    local bat_file
    local img_pack
    local pack_files
    local tag
    printf "finding tests compatible with %s phase settings ...\n" "$phase"
    case $phase in
    build|build-images)
        for i in $images $examples; do
           if test_make_check_image "$i"; then
               echo "found: $i"
               build_targets+=( "$i" )
           fi
        done
        printf '\n'
        printf 'generate build_auto.bats ...\n'
        test_make_auto "$phase" "${build_targets[@]}" > "${TMP_}/build_auto.bats"
        printf 'ok\n\n'
        ;;
    run)
        # For each tarball or squashfs file in --pack-dir look for a
        # corresponding example or image that produces a matching tag. If
        # found, check the image for exclusion conidtions.
        pack_files=$(find "$CLEARLY_TEST_TARDIR"     -name '*.tar.gz' \
                                            -o  -name '*.sqfs' | sort)
        for i in $pack_files; do
            img_pack=${i##*/}
            img_pack=${img_pack%%.*}
            for j in $images $examples; do
                if [[ $(test_make_tag_from_path "$j") == "$img_pack" ]]; then
                    if test_make_check_image "$j"; then
                        echo "found: $i"
                        run_targets+=( "$j" )
                    fi
                fi
            done
        done
        printf '\n'
        printf 'generate run_auto.bats ...\n'
        test_make_auto "$phase" "${run_targets[@]}" > "${TMP_}/run_auto.bats"
        printf 'ok\n\n'
        ;;
    examples)
        if [[ $CLEARLY_TEST_SCOPE == quick ]]; then
            echo 'skipping examples phase in quick scope'
            return
        fi
        for i in $examples; do
            if test_make_check_image "$i"; then
                bat_file=$(dirname "$i")/test.bats
                tag=$(test_make_tag_from_path "$i")
                cp "$bat_file" "${TMP_}/${tag}_example.bats"
                # Substitute $clearly_test_tag here with sed because we run all the
                # examples together later, but the value needs to vary between
                # the files. Watch the escaping here.
                sed -i "s/\\\$clearly_test_tag/${tag}/g" \
                       "${TMP_}/${tag}_example.bats"
                echo "found: $(dirname "$i")"
            fi
        done
        printf '\n'
        printf 'generate example bat files ...\n'
        printf 'ok\n\n'
        ;;
    *)
        ;;
    esac
}

test_make_auto () {
    local mode
    mode=$1;shift
    if [[ $mode != tag ]]; then
        printf "# Do not edit this file; it's autogenerated\n\n"
        printf "load %s/common.bash\n\n" "$TEST_DIR"
    fi
    while [[ "$#" -gt 0 ]]; do
        path_=$1;shift
        basename_=$(basename "$path_")
        dirname_=$(dirname "$path_")
        tag=$(test_make_tag_from_path "$path_")

        if [[ $dir == "" ]];then
            dir='.'
        fi

        if [[ $mode == tag ]]; then
            echo "$tag"
            exit 0
        fi

        if [[ $mode == build* ]]; then
            case $basename_ in
                Build|Build.*)
                    test_make_template_print 'build_custom.bats.in'
                    ;;
                Dockerfile|Dockerfile.*)
                    test_make_template_print 'build.bats.in'
                    test_make_template_print 'builder_to_archive.bats.in'
                    ;;
                *)
                    fatal "test_make_auto: unknown build type"
                    ;;
            esac
        elif [[ $mode == run ]];then
            test_make_template_print 'unpack.bats.in'
        else
             fatal "test_make_auto: invalid mode '$mode'"
        fi
    done
}

test_make_check_image () {
    img_ok=yes
    img=$1
    dir=$(basename "$(dirname "$img")")

    arch_exclude=$(cat "$img" | grep -F 'test-arch-exclude: ' \
                              | sed 's/.*: //' | awk '{print $1}')

    builder_include=$(cat "$img" | grep -F 'test-builder-include: ' \
                                 | sed 's/.*: //' | awk '{print $1}')

    builder_exclude=$(cat "$img" | grep -F 'test-builder-exclude: ' \
                                 | sed 's/.*: //' | awk '{print $1}')

    img_scope_str=$(cat "$img" | grep -F 'test-scope' \
                               | sed 's/.*: //' \
                               | awk '{print $1}')
    [[ -n $img_scope_str ]] || fatal "no scope: $img"
    img_scope_int=$(scope_to_digit "$img_scope_str")
    [[ -n $img_scope_int ]] || exit 1  # set -e not working, why?

    sudo_required=$(cat "$img" | grep -F 'test-need-sudo')

    if [[ $phase == 'build' ]]; then
        # Exclude Dockerfiles if we have no builder.
        if [[ $CLEARLY_TEST_BUILDER == none && $img == *Dockerfile* ]]; then
            pq_missing "$img" 'builder required'
            img_ok=
        fi
        # Exclude if included builders are given and $CLEARLY_TEST_BUILDER isnâ€™t one.
        if [[ -n $builder_include ]]; then
            builder_ok=
            for b in $builder_include; do
                if [[ $b == "$CLEARLY_TEST_BUILDER" ]]; then
                    builder_ok=yes
                fi
            done
            if [[ -z $builder_ok ]]; then
                pq_missing "$img" "builder not included: ${CLEARLY_TEST_BUILDER}"
                img_ok=
            fi
        fi
        # Exclude images that are not compatible with CLEARLY_TEST_BUILDER.
        for b in $builder_exclude; do
            if [[ $b == "$CLEARLY_TEST_BUILDER" ]]; then
                pq_missing "$img" "builder excluded: ${CLEARLY_TEST_BUILDER}"
                img_ok=
            fi
        done
    fi

    # Exclude images with a scope that is not a subset of CLEARLY_TEST_SCOPE.
    if [[ $scope_int -lt "$img_scope_int" ]]; then
        pq_missing "$img" "not in scope: ${CLEARLY_TEST_SCOPE}"
        img_ok=
    fi

    # Exclude images that do not work with the host architecture.
    for a in $arch_exclude; do
        if [[ $a == "$(uname -m)" ]]; then
            pq_missing "$img" "incompatible architecture: ${a}"
            img_ok=
        fi
    done

    # Exclude images that require sudo if CLEARLY_TEST_SUDO is empty
    if [[ -n $sudo_required && -z $CLEARLY_TEST_SUDO ]]; then
        pq_missing "$img" 'generic sudo required'
        img_ok=
    fi

    # In examples phase, exclude test and any images not in a subdirectory of
    # examples.
    if [[ $phase == examples && ( $dir == test || $dir == examples ) ]]; then
        img_ok=
    fi

    if [[ -n $img_ok ]]; then
        return 0  # include image
    else
        return 1  # exclude image
    fi
}

test_make_tag_from_path () {
    # Generate a tag from given path.
    #
    # Consider the following path: $TEST/examples/Dockerfile.openmpi
    # First break the path into four components:
    #   1) dir:        the parent directory of the file (examples)
    #   2) base:       the full file name (Dockerfile.openmpi)
    #   3) basicname:  the file name (Dockerfile)
    #   4) extension:  the file's extension (openmpi)
    #
    # $basicname must be â€œBuildâ€ or â€œDockerfileâ€; otherwise error.
    # if $dir is â€œ.â€, â€œtestâ€, or â€œexamplesâ€ then tag=$extension; otherwise
    # tag is $extension if set or $dir-$exenstion.
    local base
    local basicname
    local dir
    local extension
    local tag
    dir=$(basename "$(dirname "$1")")  # last directory only
    base=$(basename "$1")
    basicname=${base%%.*}
    extension=${base##*.}

    if [[ $extension == "$basicname" ]]; then
        extension=''
    else
        extension=${extension/\./} # remove dot
    fi

    case $basicname in
        Build|Dockerfile)
            case $dir in
                .|examples|clearly|test) # dot is directory â€œtestâ€
                    if [[ -z $extension ]]; then
                        fatal "can't compute tag: $1"
                    else
                        tag=$extension
                    fi
                    ;;
                *)
                    if [[ -z $extension ]]; then
                        tag=$(basename "$dir")
                    else
                        tag=$(basename "${dir}-${extension}")
                    fi
            esac
            ;;
        *)
            fatal "test_make_auto: invalid basic name '$basicname'"
            ;;
    esac
    echo "$tag"
}

test_make_template_print () {
    local template
    template="./make-auto.d/$1"

    # Subsitute template variables and remove â€œsourceâ€ command that is only
    # for ShellCheck.
      cat "$template" \
    | sed -E -e 's/^(source common\.bash.*)$/#\1/' \
             -e "s@%\(basename\)s@$basename_@g" \
             -e "s@%\(dirname\)s@$dirname_@g" \
             -e "s@%\(path\)s@$path_@g" \
             -e "s@%\(scope\)s@$CLEARLY_TEST_SCOPE@g" \
             -e "s@%\(tag\)s@$tag@g"
    printf '\n'
}

test_one_file () {
    if [[ $one_file != *.bats ]]; then
        # Assume it's a Dockerfile or Build file; derive tag and test.bats.
        clearly_test_tag=$(test_make_tag_from_path "$one_file")
        export clearly_test_tag
        one_file=$(dirname "$one_file")/test.bats
        printf 'tag:   %s\n' "$clearly_test_tag"
    fi
    printf 'file:  %s\n' "$one_file"
    bats "$one_file"
}

test_rootemu () {
    if command -v image > /dev/null 2>&1; then
        bats force-auto.bats
        echo yes > "$TMP_/rootemu"
    elif [[ -n "$1" ]]; then
        printf "error: image required, not found\n"
        exit 1
    fi
}

test_run () {
    echo 'executing run phase tests ...'
    if [[ ! -f ${TMP_}/run_auto.bats ]]; then
        fatal "${TMP_}/run_auto.bats not found"
    fi
    bats run_first.bats "${TMP_}/run_auto.bats" ./run/*.bats
    if [[ $CLEARLY_TEST_SCOPE != quick ]]; then
        for guest_user in $(id -un) root nobody; do
            for guest_group in $(id -gn) root $(id -gn nobody); do
                export GUEST_USER=$guest_user
                export GUEST_GROUP=$guest_group
                echo "testing as $GUEST_USER $GUEST_GROUP"
                bats run/run_uidgid.bats
            done
        done
    fi
}

# Exit with failure if given version number is below a minimum.
#
# $1: human-readable descriptor
# $2: minimum version
# $3: actual version
version_check () {
    desc=$1
    min=$2
    actual=$3
    if [[ $(  printf '%s\n%s\n' "$min" "$actual" \
            | sort -V | head -n1) != "$min" ]]; then
        fatal "$desc: mininum version $min, found $actual"
    fi
}

win () {
    printf "\nAll tests passed.\n"
}


### Body of script

# Set $USER. Do this unconditionally to have the same username-finding logic
# as the main programs. See #1162.
USER=$(id -un)
export USER

# Ensure run has been compiled (issue #329).
if ! "${clearly_bin}/clearly" --version > /dev/null 2>&1; then
    fatal "no working run found in $clearly_bin"
fi

# Some tests have specific libc requirements.
case $(readelf -p .interp "${clearly_bin}/clearly run") in
    *musl*)            # e.g. /lib/ld-musl-x86_64.so.1
        export clearly_libc=musl
        ;;
    *)                 # e.g. /lib64/ld-linux-x86-64.so.2
        export clearly_libc=glibc
        ;;
esac

# Ensure we have Bash 4.1 or higher
if /bin/bash -c 'set -e; [[ 1 = 0 ]]; exit 0'; then
    # Bash bug: [[ ... ]] expression doesn't exit with set -e
    # https://github.com/sstephenson/bats/issues/49
    fatal 'Bash minimum version is 4.1'
fi

# Ensure Bats is installed.
if command -v bats > /dev/null 2>&1; then
    bats=$(command -v bats)
    bats_version="$(bats --version | awk '{print $2}')"
else
    fatal 'Bats not found'
fi

# Reject non-default registry on GitHub Actions.
if [[ -n $GITHUB_ACTIONS && -n $CLEARLY_REGY_DEFAULT_HOST ]]; then
    fatal 'non-default registry on GitHub Actions invalid'
fi

# Create a directory to hold auto-generated test artifacts.
TMP_=/tmp/clearly-test.tmp.$USER
if [[ ! -d $TMP_ ]]; then
    mkdir "$TMP_"
    chmod 700 "$TMP_"
fi

# Record that we havenâ€™t (yet) run the â€œrootemuâ€ tests
echo no > "$TMP_/rootemu"

# Find test directories. Note some of this gets rewritten at install time.
TEST_DIR=${clearly_base}/test
TEST_EXAMPLES_DIR=${clearly_base}/examples
if [[ ! -f ${clearly_base}/VERSION ]]; then
    # installed
    TEST_INSTALLED=yes
    TEST_GITWD=
else
    # build dir
    TEST_INSTALLED=
    if [[ -e ${clearly_base}/.git ]]; then
        TEST_GITWD=yes
    else
        TEST_GITWD=
    fi
fi
export clearly_base
export TEST_INSTALLED
export TEST_GITWD
export TEST_DIR
export TEST_EXAMPLES_DIR
export TMP_

# Check for test directory.
if [[ ! -d $TEST_DIR ]]; then
    fatal "test directory not found: $TEST_DIR"
fi
if [[ ! -d $TEST_EXAMPLES_DIR ]]; then
    fatal "examples not found: $TEST_EXAMPLES_DIR"
fi

# Parse arguments.
if [[ $# == 0 ]]; then
    usage 1
fi
while [[ $# -gt 0 ]]; do
    opt=$1; shift
    case $opt in
    all|build|build-images|clean|examples|mk-perm-dirs|rm-perm-dirs|rootemu|run)
        require_unset phase
        phase=$opt
        ;;
    -b|--builder)
        require_unset builder
        builder=$1; shift
        ;;
    --builder=*)
        require_unset builder
        builder=${opt#*=}
        ;;
    -c|--bucache-mode)
        require_unset bucache_mode
        bucache_mode=$1; shift
        ;;
    --bucache-mode=*)
        require_unset bucache_mode
        bucache_mode=${opt#*=}
        ;;
    --dry-run)
        dry=true
        ;;
    -f|--file)
        require_unset phase
        phase=one-file
        one_file=$1; shift
        ;;
    --file=*)
        require_unset phase
        phase=one-file
        one_file=${opt#*=}
        ;;
    -h|--help)
        usage 0
        ;;
    --img-dir)
        require_unset imgdir
        imgdir=$1; shift
        ;;
    --img-dir=*)
        require_unset imgdir
        imgdir=${opt#*=}
        ;;
    --is-pedantic)  # undocumented; for CI
        is_pedantic=yes
        ;;
    --is-sudo)      # undocumented; for CI
        is_sudo=yes
        ;;
    --fi-path)
        require_unset fi_path
        fi_path=$1; shift
        ;;
    --fi-path=*)
        require_unset fi_path
        fi_path=${opt#*=}
        ;;
    --pack-dir)
        require_unset tardir
        tardir=$1; shift
        ;;
    --pack-dir=*)
        require_unset tardir
        tardir=${opt#*=}
        ;;
    --pack-fmt)
        require_unset pack_fmt
        pack_fmt=$1; shift
        ;;
    --pack-fmt=*)
        require_unset pack_fmt
        pack_fmt=${opt#*=}
        ;;
    --pedantic)
        pedantic=$1; shift
        ;;
    --pedantic=*)
        pedantic=${opt#*=}
        ;;
    --perm-dir)
        use_sudo=yes
        permdirs+=("$1"); shift
        ;;
    --perm-dir=*)
        use_sudo=yes
        permdirs+=("${opt#*=}")
        ;;
    -s|--scope)
        require_unset scope
        scope_check "$1"
        scope=$1; shift
        ;;
    --scope=*)
        require_unset scope
        scope=${opt#*=}
        scope_check "$scope"
        ;;
    --sudo)
        use_sudo=yes
        ;;
    --srun-mpi=*)
        require_unset srun_mpi
        srun_mpi="${opt#*=}"
        ;;
    --srun-mpi)
        require_unset srun_mpi
        srun_mpi=$1; shift
        ;;
    --lustre)
        require_unset lustredir
        lustredir=$1; shift
        ;;
    --lustre=*)
        require_unset lustredir
        lustredir=${opt#*=}
        ;;
    *)
        fatal "unrecognized argument: $opt"
        ;;
    esac
done

printf 'run:       %s (%s)\n' "${clearly_bin}/run" "$clearly_libc"
printf 'bats:         %s (%s)\n' "$bats" "$bats_version"
if [[    $(printf "%s\n%s" "$bats_version" "$bats_vmin" | sort -V | head -1) \
      != "$bats_vmin" ]]; then
    warning "Bats version unsupported b/c < $bats_vmin"
fi
printf 'tests:        %s\n' "$TEST_DIR"
printf 'installed:    %s\n' "${TEST_INSTALLED:-no}"
printf 'locale:       %s\n' "$LC_ALL"
printf 'git workdir:  %s\n' "${TEST_GITWD:-no}"

if [[ $phase = one-file ]]; then
    if [[ $one_file == *:* ]]; then
        x=$one_file
        one_file=${x%%:*}            # before first colon
        export clearly_one_test=${x#*:}   # after first colon
    fi
    if [[ ! -f $one_file ]]; then
        fatal "not a file: $one_file"
    fi
    one_file=$(readlink -f "$one_file")  # make absolute b/c we cd later
    if [[ $one_file = */test.bats ]]; then
        fatal '--file: must specify build recipe file, not test.bats'
    fi
fi

printf "%-21s %s" 'phase:' "$phase"
if [[ $phase = one-file ]]; then
    printf ': %s (%s)' "$one_file" "$clearly_one_test"
fi
if [[ -z $phase ]]; then
    fatal 'phase: no phase specified'
fi
printf '\n'

#    variable name    CLI              environment         default
#                     desc. width  description
vset CLEARLY_TEST_SCOPE    "$scope"         "$CLEARLY_TEST_SCOPE"    standard \
                      21 'scope'
builder_set 21
pedantry_set 21
vset CLEARLY_TEST_SUDO     "$use_sudo"      "$CLEARLY_TEST_SUDO"     "$use_sudo_default" \
                      21 'use generic sudo'
vset CLEARLY_TEST_IMGDIR   "$imgdir"        "$CLEARLY_TEST_IMGDIR"   "/var/tmp/${USER}.img" \
                      21 'unpacked images dir'
vset CLEARLY_TEST_TARDIR   "$tardir"        "$CLEARLY_TEST_TARDIR"   "/var/tmp/${USER}.pack" \
                      21 'packed images dir'
pack_fmt_set 21
vset CLEARLY_IMAGE_CACHE   "$bucache_mode"  "$CLEARLY_IMAGE_CACHE"   enabled \
                      21 'build cache mode'
vset CLEARLY_TEST_PERMDIRS "${permdirs[*]}" "$CLEARLY_TEST_PERMDIRS" skip \
                      21 'fs permissions dirs'
vset CLEARLY_TEST_LUSTREDIR "$lustredir"    "$CLEARLY_TEST_LUSTREDIR" skip \
                      21 'Lustre test dir'
vset CLEARLY_TEST_SLURM_MPI "$srun_mpi"     "$CLEARLY_TEST_SLURM_MPI" "$SLURM_MPI_TYPE" \
                      21 'srun mpi type'
vset CLEARLY_TEST_OFI_PATH  "$fi_path"     "$CLEARLY_TEST_OFI_PATH"  skip \
                      21 'ofi provider(s) path'
printf '\n'

if [[ $phase == *'perm'* ]] && [[ $CLEARLY_TEST_PERMDIRS == skip ]]; then
    fatal "phase $phase: CLEARLY_TEST_PERMDIRS: can't be 'skip'"
fi

# Ensure ofi path looks sane.
if [[ -n "$fi_path" ]]; then
    case "$fi_path" in
        *-fi.so)
        true
     ;;
    *libfabric.so)
        true
    ;;
     *)
    fatal '--fi-path: must end in -fi.so or libfabric.so'
    esac
fi

# Don't allow FI_ variables.
if [[ -n "$FI_PROVIDER" ]]; then
    fatal 'host FI_PROVIDER set'
fi
if [[ -n "$FI_PROVIDER_PATH" ]]; then
    fatal 'host FI_PROVIDER_PATH set'
fi

# If srun --mpi=pmix, set variable to avoid spurious error. See
# https://github.com/open-mpi/ompi/issues/7516.
if [[ "$CLEARLY_TEST_SLURM_MPI" == 'pmix'* ]]; then
    export PMIX_MCA_gds=hash
fi

# Ensure BATS_TMPDIR is set to /tmp (issue #278).
if [[ -n $BATS_TMPDIR && $BATS_TMPDIR != '/tmp' ]]; then
    fatal "BATS_TMPDIR: must be /tmp; found '$BATS_TMPDIR' (issue #278)"
fi

# Ensure namespaces are configured properly.
printf 'checking namespaces ...\n'
if ! "${clearly_bin}/check"; then
    fatal 'namespace sanity check (clearly check) failed'
fi
printf '\n'

if [[ $CLEARLY_TEST_SUDO ]]; then
    printf 'checking sudo ...\n'
    sudo echo ok
    printf '\n'
fi

if [[ -n $is_pedantic ]]; then
    printf 'exiting per --is-pedantic\n'
    if [[ -n $clearly_pedantic ]]; then exit 0; else exit 1; fi
fi

if [[ -n $is_sudo ]]; then
    printf 'exiting per --is-sudo\n'
    if [[ -n $CLEARLY_TEST_SUDO ]]; then exit 0; else exit 1; fi
fi

if [[ -n $dry ]];then
    printf 'exiting per --dry-run\n'
    exit 0
fi

cd "$TEST_DIR"

export PATH=$clearly_bin:$PATH

# Now that CLEARLY_TEST_* variables, PATH, and BATS_TMPDIR has been set and checked,
# we source TEST_DIR/common.bash.
. "${TEST_DIR}/common.bash"

# The distinction here is that â€œimagesâ€ are purely for testing and have no
# value as examples for the user, while â€œexamplesâ€ are dual-purpose. We call
# â€œfindâ€ twice for each to preserve desired sort order.
images=$(     find "$TEST_DIR"             -name 'Dockerfile.*' | sort \
           && find "$TEST_DIR"             -name 'Build' \
                                          -o -name 'Build.*' | sort)
examples=$(   find "$TEST_EXAMPLES_DIR"    -name 'Dockerfile' \
                                          -o -name 'Dockerfile.*' | sort \
           && find "$TEST_EXAMPLES_DIR"    -name 'Build' \
                                          -o -name 'Build.*' | sort)

scope_int=$(scope_to_digit "$CLEARLY_TEST_SCOPE")

# Execute phase
case $phase in
    all)
        phase=build
        dir_tar_mk
        builder_check
        test_make
        test_build_images
        test_build

        phase=rootemu
        if [[ "$scope" != "full" ]]; then
            echo "skipping root emulation tests (full scope only)"
        else
            echo 'executing root emulation tests...'
            test_rootemu
        fi

        phase=run
        dir_img_mk
        dir_tar_check
        test_make
        test_run

        phase=examples
        dir_tar_check
        test_make
        test_examples

        # Kobe.
        win
        ;;
    build)
        builder_check
        dir_tar_mk
        test_make
        test_build_images
        test_build
        win
        ;;
    clean)
        dirs_unpriv_rm
        if [[ -d $TMP_ ]] && [[ -e $TMP_/build_auto.bats ]]; then
            echo "removing $TMP_"
            rm -rf --one-file-system "$TMP_"
        fi
        ;;
    examples)
        test_make
        test_examples
        win
        ;;
    build-images)
        builder_check
        dir_tar_mk
        test_make
        test_build_images
        win
        ;;
    mk-perm-dirs)
        printf 'creating filesystem permissions fixtures ...\n'
        for d in $CLEARLY_TEST_PERMDIRS; do
            if [[ -d ${d} ]]; then
                printf '%s already exists\n' "$d"
                continue
            else
                sudo "${TEST_DIR}/make-perms-test" "$d" "$USER" nobody
            fi
        done
        echo
        ;;
    one-file)
        test_one_file
        win
        ;;
    rm-perm-dirs)
        for d in $CLEARLY_TEST_PERMDIRS; do
            dir_perm_rm "$d"
        done
        ;;
    rootemu)
        test_rootemu optional # image optional
        ;;
    run)
        dir_img_mk
        test_make
        test_run
        win
        ;;
esac
